2022-03-04 10:17:57:690 grammar LogManager.java:25 before: (PARSER_GRAMMAR Chems (OPTIONS (= tokenVocab ChemsLexer)) (@ header {
    import "OLC2/interfaces"
    import "OLC2/expresion"
    import "OLC2/instruction"
    import arrayList "github.com/colegno/arraylist"
}) (RULES (RULE start (returns *arrayList.List lista) (BLOCK (ALT instrucciones {$lista = $instrucciones.l}))) (RULE instrucciones (returns *arrayList.List l) (@ init {
    $l =  arrayList.New()
  }) (BLOCK (ALT (* (BLOCK (ALT (+= e instruccion)))) {
      listInt := localctx.(*InstruccionesContext).GetE()
      		for _, e := range listInt {
            $l.Add(e.GetInstr())
          }
    }))) (RULE instruccion (returns interfaces.Instruction instr) (BLOCK (ALT CONSOLE '.' LOG PARIZQ expression PARDER ';' {$instr = instruction.NewImprimir($expression.p)}) (ALT P_NUMBER (= isArray array_st) (= id ID) '=' expression ';' {$instr = instruction.NewDeclaration($id.text,interfaces.INTEGER,$expression.p, $isArray.arr)}) (ALT (= id ID) '=' expression ';' {$instr = instruction.NewAssignment($id.text,$expression.p)}) (ALT P_IF PARIZQ expression PARDER LLAVEIZQ instrucciones LLAVEDER {$instr = instruction.NewIf($expression.p, $instrucciones.l)}) (ALT P_WHILE PARIZQ expression PARDER LLAVEIZQ instrucciones LLAVEDER {$instr = instruction.NewWhile($expression.p, $instrucciones.l)}) (ALT P_STRUCT (= id ID) LLAVEIZQ (= lista lista_att) LLAVEDER {$instr = instruction.NewStruct($id.text, $lista.l)}))) (RULE lista_att (returns *arrayList.List l) (BLOCK (ALT lista_att ',' (= id ID) ':' P_NUMBER { 
                                        $list.l.Add($id.text);
                                        $l = $list.l;
                                    }) (ALT (= id ID) ':' P_NUMBER { 
                    $l = arrayList.New();
                    $l.Add($id.text);
                }))) (RULE array_st (returns bool arr) (BLOCK (ALT CORIZQ CORDER { $arr = true }) (ALT EPSILON))) (RULE expression (returns interfaces.Expresion p) (BLOCK (ALT expr_arit {$p = $expr_arit.p}))) (RULE expr_arit (returns interfaces.Expresion p) (BLOCK (ALT (= opIz expr_arit) (= op (BLOCK (ALT '*') (ALT '/'))) (= opDe expr_arit) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT (= opIz expr_arit) (= op (BLOCK (ALT '+') (ALT '-'))) (= opDe expr_arit) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT (= opIz expr_arit) (= op (BLOCK (ALT '<') (ALT '<=') (ALT '>=') (ALT '>'))) (= opDe expr_arit) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT CORIZQ listValues CORDER { $p = expresion.NewArray($listValues.l) }) (ALT primitivo {$p = $primitivo.p}) (ALT PARIZQ expression PARDER {$p = $expression.p}))) (RULE listValues (returns *arrayList.List l) (BLOCK (ALT (= list listValues) ',' expression { 
                                        $list.l.Add($expression.p)
                                        $l = $list.l
                                    }) (ALT expression { 
                    $l = arrayList.New()
                    $l.Add($expression.p)
                }))) (RULE primitivo (returns interfaces.Expresion p) (BLOCK (ALT NUMBER {
            	num,err := strconv.Atoi($NUMBER.text)
                if err!= nil{
                    fmt.Println(err)
                }
            $p = expresion.NewPrimitivo (num,interfaces.INTEGER)
       }) (ALT STRING { 
      str:= $STRING.text[1:len($STRING.text)-1]
      $p = expresion.NewPrimitivo(str,interfaces.STRING)}) (ALT (= list listArray) { $p = $list.p}))) (RULE listArray (returns interfaces.Expresion p) (BLOCK (ALT (= list listArray) CORIZQ expression CORDER { $p = expresion.NewArrayAccess($list.p, $expression.p) }) (ALT ID { $p = expresion.NewCallVariable($ID.text)})))))
2022-03-04 10:17:57:703 grammar LogManager.java:25 after: (PARSER_GRAMMAR Chems (OPTIONS (= tokenVocab ChemsLexer)) (@ header {
    import "OLC2/interfaces"
    import "OLC2/expresion"
    import "OLC2/instruction"
    import arrayList "github.com/colegno/arraylist"
}) (RULES (RULE start (returns *arrayList.List lista) (BLOCK (ALT instrucciones {$lista = $instrucciones.l}))) (RULE instrucciones (returns *arrayList.List l) (@ init {
    $l =  arrayList.New()
  }) (BLOCK (ALT (* (BLOCK (ALT (+= e instruccion)))) {
      listInt := localctx.(*InstruccionesContext).GetE()
      		for _, e := range listInt {
            $l.Add(e.GetInstr())
          }
    }))) (RULE instruccion (returns interfaces.Instruction instr) (BLOCK (ALT CONSOLE '.' LOG PARIZQ expression PARDER ';' {$instr = instruction.NewImprimir($expression.p)}) (ALT P_NUMBER (= isArray array_st) (= id ID) '=' expression ';' {$instr = instruction.NewDeclaration($id.text,interfaces.INTEGER,$expression.p, $isArray.arr)}) (ALT (= id ID) '=' expression ';' {$instr = instruction.NewAssignment($id.text,$expression.p)}) (ALT P_IF PARIZQ expression PARDER LLAVEIZQ instrucciones LLAVEDER {$instr = instruction.NewIf($expression.p, $instrucciones.l)}) (ALT P_WHILE PARIZQ expression PARDER LLAVEIZQ instrucciones LLAVEDER {$instr = instruction.NewWhile($expression.p, $instrucciones.l)}) (ALT P_STRUCT (= id ID) LLAVEIZQ (= lista lista_att) LLAVEDER {$instr = instruction.NewStruct($id.text, $lista.l)}))) (RULE lista_att (returns *arrayList.List l) (BLOCK (ALT lista_att ',' (= id ID) ':' P_NUMBER { 
                                        $list.l.Add($id.text);
                                        $l = $list.l;
                                    }) (ALT (= id ID) ':' P_NUMBER { 
                    $l = arrayList.New();
                    $l.Add($id.text);
                }))) (RULE array_st (returns bool arr) (BLOCK (ALT CORIZQ CORDER { $arr = true }) (ALT EPSILON))) (RULE expression (returns interfaces.Expresion p) (BLOCK (ALT expr_arit {$p = $expr_arit.p}))) (RULE expr_arit (returns interfaces.Expresion p) (BLOCK (ALT (= opIz expr_arit) (= op (SET '*' '/')) (= opDe expr_arit) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT (= opIz expr_arit) (= op (SET '+' '-')) (= opDe expr_arit) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT (= opIz expr_arit) (= op (SET '<' '<=' '>=' '>')) (= opDe expr_arit) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT CORIZQ listValues CORDER { $p = expresion.NewArray($listValues.l) }) (ALT primitivo {$p = $primitivo.p}) (ALT PARIZQ expression PARDER {$p = $expression.p}))) (RULE listValues (returns *arrayList.List l) (BLOCK (ALT (= list listValues) ',' expression { 
                                        $list.l.Add($expression.p)
                                        $l = $list.l
                                    }) (ALT expression { 
                    $l = arrayList.New()
                    $l.Add($expression.p)
                }))) (RULE primitivo (returns interfaces.Expresion p) (BLOCK (ALT NUMBER {
            	num,err := strconv.Atoi($NUMBER.text)
                if err!= nil{
                    fmt.Println(err)
                }
            $p = expresion.NewPrimitivo (num,interfaces.INTEGER)
       }) (ALT STRING { 
      str:= $STRING.text[1:len($STRING.text)-1]
      $p = expresion.NewPrimitivo(str,interfaces.STRING)}) (ALT (= list listArray) { $p = $list.p}))) (RULE listArray (returns interfaces.Expresion p) (BLOCK (ALT (= list listArray) CORIZQ expression CORDER { $p = expresion.NewArrayAccess($list.p, $expression.p) }) (ALT ID { $p = expresion.NewCallVariable($ID.text)})))))
2022-03-04 10:17:57:872 left-recursion LogManager.java:25 lista_att returns [*arrayList.List l]
    :   ( {} id=ID<tokenIndex=197> ':'<tokenIndex=199> P_NUMBER<tokenIndex=201>  { 
                    $l = arrayList.New();
                    $l.Add($id.text);
                } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> ','<tokenIndex=181> id=ID<tokenIndex=185> ':'<tokenIndex=187> P_NUMBER<tokenIndex=189> { 
                                                  $list.l.Add($id.text);
                                                  $l = $list.l;
                                              }
        )*
    ;
2022-03-04 10:17:57:876 grammar LogManager.java:25 added: (RULE lista_att (returns *arrayList.List l) (BLOCK (ALT (BLOCK (ALT {} (= id (ID (ELEMENT_OPTIONS (= tokenIndex 197)))) (':' (ELEMENT_OPTIONS (= tokenIndex 199))) (P_NUMBER (ELEMENT_OPTIONS (= tokenIndex 201))) { 
                    $l = arrayList.New();
                    $l.Add($id.text);
                })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (',' (ELEMENT_OPTIONS (= tokenIndex 181))) (= id (ID (ELEMENT_OPTIONS (= tokenIndex 185)))) (':' (ELEMENT_OPTIONS (= tokenIndex 187))) (P_NUMBER (ELEMENT_OPTIONS (= tokenIndex 189))) { 
                                                  $list.l.Add($id.text);
                                                  $l = $list.l;
                                              }))))))
2022-03-04 10:17:57:967 left-recursion LogManager.java:25 expr_arit returns [interfaces.Expresion p]
    :   ( {} CORIZQ<tokenIndex=321> listValues<tokenIndex=323> CORDER<tokenIndex=325> { $p = expresion.NewArray($listValues.l) } 
        | primitivo<tokenIndex=331> {$p = $primitivo.p} 
        | PARIZQ<tokenIndex=337> expression<tokenIndex=339> PARDER<tokenIndex=341> {$p = $expression.p} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 6)}?<p=6> op=('*'<tokenIndex=254>|'/'<tokenIndex=256>) opDe = expr_arit<tokenIndex=263,p=7> {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}
                  | {p.Precpred(p.GetParserRuleContext(), 5)}?<p=5> op=('+'<tokenIndex=278>|'-'<tokenIndex=280>) opDe = expr_arit<tokenIndex=287,p=6> {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}
                  | {p.Precpred(p.GetParserRuleContext(), 4)}?<p=4> op=('<'<tokenIndex=302>|'<='<tokenIndex=304>|'>='<tokenIndex=306>|'>'<tokenIndex=308>) opDe = expr_arit<tokenIndex=315,p=5> {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}
        )*
    ;
2022-03-04 10:17:57:974 grammar LogManager.java:25 added: (RULE expr_arit (returns interfaces.Expresion p) (BLOCK (ALT (BLOCK (ALT {} (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 321))) (listValues (ELEMENT_OPTIONS (= tokenIndex 323))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 325))) { $p = expresion.NewArray($listValues.l) }) (ALT (primitivo (ELEMENT_OPTIONS (= tokenIndex 331))) {$p = $primitivo.p}) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 337))) (expression (ELEMENT_OPTIONS (= tokenIndex 339))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 341))) {$p = $expression.p})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 6)}? (ELEMENT_OPTIONS (= p 6))) (= op (SET ('*' (ELEMENT_OPTIONS (= tokenIndex 254))) ('/' (ELEMENT_OPTIONS (= tokenIndex 256))))) (= opDe (expr_arit (ELEMENT_OPTIONS (= tokenIndex 263) (= p 7)))) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT ({p.Precpred(p.GetParserRuleContext(), 5)}? (ELEMENT_OPTIONS (= p 5))) (= op (SET ('+' (ELEMENT_OPTIONS (= tokenIndex 278))) ('-' (ELEMENT_OPTIONS (= tokenIndex 280))))) (= opDe (expr_arit (ELEMENT_OPTIONS (= tokenIndex 287) (= p 6)))) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}) (ALT ({p.Precpred(p.GetParserRuleContext(), 4)}? (ELEMENT_OPTIONS (= p 4))) (= op (SET ('<' (ELEMENT_OPTIONS (= tokenIndex 302))) ('<=' (ELEMENT_OPTIONS (= tokenIndex 304))) ('>=' (ELEMENT_OPTIONS (= tokenIndex 306))) ('>' (ELEMENT_OPTIONS (= tokenIndex 308))))) (= opDe (expr_arit (ELEMENT_OPTIONS (= tokenIndex 315) (= p 5)))) {$p = expresion.NewOperacion($opIz.p,$op.text,$opDe.p,false)}))))))
2022-03-04 10:17:58:032 left-recursion LogManager.java:25 listValues returns [*arrayList.List l]
    :   ( {} expression<tokenIndex=366> { 
                    $l = arrayList.New()
                    $l.Add($expression.p)
                } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> ','<tokenIndex=358> expression<tokenIndex=360> { 
                                                  $list.l.Add($expression.p)
                                                  $l = $list.l
                                              }
        )*
    ;
2022-03-04 10:17:58:034 grammar LogManager.java:25 added: (RULE listValues (returns *arrayList.List l) (BLOCK (ALT (BLOCK (ALT {} (expression (ELEMENT_OPTIONS (= tokenIndex 366))) { 
                    $l = arrayList.New()
                    $l.Add($expression.p)
                })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (',' (ELEMENT_OPTIONS (= tokenIndex 358))) (expression (ELEMENT_OPTIONS (= tokenIndex 360))) { 
                                                  $list.l.Add($expression.p)
                                                  $l = $list.l
                                              }))))))
2022-03-04 10:17:58:073 left-recursion LogManager.java:25 listArray returns [interfaces.Expresion p]
    :   ( {} ID<tokenIndex=421> { $p = expresion.NewCallVariable($ID.text)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CORIZQ<tokenIndex=411> expression<tokenIndex=413> CORDER<tokenIndex=415> { $p = expresion.NewArrayAccess($list.p, $expression.p) }
        )*
    ;
2022-03-04 10:17:58:074 grammar LogManager.java:25 added: (RULE listArray (returns interfaces.Expresion p) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 421))) { $p = expresion.NewCallVariable($ID.text)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 411))) (expression (ELEMENT_OPTIONS (= tokenIndex 413))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 415))) { $p = expresion.NewArrayAccess($list.p, $expression.p) }))))))
2022-03-04 10:17:58:088 grammar LogManager.java:25 import CONSOLE=1
2022-03-04 10:17:58:088 grammar LogManager.java:25 import LOG=2
2022-03-04 10:17:58:088 grammar LogManager.java:25 import P_NUMBER=3
2022-03-04 10:17:58:088 grammar LogManager.java:25 import P_STRING=4
2022-03-04 10:17:58:089 grammar LogManager.java:25 import P_IF=5
2022-03-04 10:17:58:089 grammar LogManager.java:25 import P_WHILE=6
2022-03-04 10:17:58:089 grammar LogManager.java:25 import P_STRUCT=7
2022-03-04 10:17:58:089 grammar LogManager.java:25 import NUMBER=8
2022-03-04 10:17:58:089 grammar LogManager.java:25 import STRING=9
2022-03-04 10:17:58:089 grammar LogManager.java:25 import ID=10
2022-03-04 10:17:58:089 grammar LogManager.java:25 import PUNTO=11
2022-03-04 10:17:58:089 grammar LogManager.java:25 import PTCOMA=12
2022-03-04 10:17:58:089 grammar LogManager.java:25 import COMA=13
2022-03-04 10:17:58:089 grammar LogManager.java:25 import DOSPT=14
2022-03-04 10:17:58:089 grammar LogManager.java:25 import DIFERENTE=15
2022-03-04 10:17:58:089 grammar LogManager.java:25 import IGUAL=16
2022-03-04 10:17:58:089 grammar LogManager.java:25 import MAYORIGUAL=17
2022-03-04 10:17:58:089 grammar LogManager.java:25 import MENORIGUAL=18
2022-03-04 10:17:58:089 grammar LogManager.java:25 import MAYOR=19
2022-03-04 10:17:58:089 grammar LogManager.java:25 import MENOR=20
2022-03-04 10:17:58:089 grammar LogManager.java:25 import MUL=21
2022-03-04 10:17:58:089 grammar LogManager.java:25 import DIV=22
2022-03-04 10:17:58:089 grammar LogManager.java:25 import ADD=23
2022-03-04 10:17:58:089 grammar LogManager.java:25 import SUB=24
2022-03-04 10:17:58:089 grammar LogManager.java:25 import PARIZQ=25
2022-03-04 10:17:58:089 grammar LogManager.java:25 import PARDER=26
2022-03-04 10:17:58:089 grammar LogManager.java:25 import LLAVEIZQ=27
2022-03-04 10:17:58:089 grammar LogManager.java:25 import LLAVEDER=28
2022-03-04 10:17:58:089 grammar LogManager.java:25 import CORIZQ=29
2022-03-04 10:17:58:090 grammar LogManager.java:25 import CORDER=30
2022-03-04 10:17:58:090 grammar LogManager.java:25 import WHITESPACE=31
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'console'=1
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'log'=2
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'number'=3
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'string'=4
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'if'=5
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'while'=6
2022-03-04 10:17:58:090 grammar LogManager.java:25 import 'struct'=7
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '.'=11
2022-03-04 10:17:58:090 grammar LogManager.java:25 import ';'=12
2022-03-04 10:17:58:090 grammar LogManager.java:25 import ','=13
2022-03-04 10:17:58:090 grammar LogManager.java:25 import ':'=14
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '!'=15
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '='=16
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '>='=17
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '<='=18
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '>'=19
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '<'=20
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '*'=21
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '/'=22
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '+'=23
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '-'=24
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '('=25
2022-03-04 10:17:58:090 grammar LogManager.java:25 import ')'=26
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '{'=27
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '}'=28
2022-03-04 10:17:58:090 grammar LogManager.java:25 import '['=29
2022-03-04 10:17:58:091 grammar LogManager.java:25 import ']'=30
2022-03-04 10:17:58:091 grammar LogManager.java:25 tokens={CONSOLE=1, LOG=2, P_NUMBER=3, P_STRING=4, P_IF=5, P_WHILE=6, P_STRUCT=7, NUMBER=8, STRING=9, ID=10, PUNTO=11, PTCOMA=12, COMA=13, DOSPT=14, DIFERENTE=15, IGUAL=16, MAYORIGUAL=17, MENORIGUAL=18, MAYOR=19, MENOR=20, MUL=21, DIV=22, ADD=23, SUB=24, PARIZQ=25, PARDER=26, LLAVEIZQ=27, LLAVEDER=28, CORIZQ=29, CORDER=30, WHITESPACE=31, 'console'=1, 'log'=2, 'number'=3, 'string'=4, 'if'=5, 'while'=6, 'struct'=7, '.'=11, ';'=12, ','=13, ':'=14, '!'=15, '='=16, '>='=17, '<='=18, '>'=19, '<'=20, '*'=21, '/'=22, '+'=23, '-'=24, '('=25, ')'=26, '{'=27, '}'=28, '['=29, ']'=30}
2022-03-04 10:17:58:091 semantics LogManager.java:25 tokens={EOF=-1, CONSOLE=1, LOG=2, P_NUMBER=3, P_STRING=4, P_IF=5, P_WHILE=6, P_STRUCT=7, NUMBER=8, STRING=9, ID=10, PUNTO=11, PTCOMA=12, COMA=13, DOSPT=14, DIFERENTE=15, IGUAL=16, MAYORIGUAL=17, MENORIGUAL=18, MAYOR=19, MENOR=20, MUL=21, DIV=22, ADD=23, SUB=24, PARIZQ=25, PARDER=26, LLAVEIZQ=27, LLAVEDER=28, CORIZQ=29, CORDER=30, WHITESPACE=31}
2022-03-04 10:17:58:091 semantics LogManager.java:25 strings={'console'=1, 'log'=2, 'number'=3, 'string'=4, 'if'=5, 'while'=6, 'struct'=7, '.'=11, ';'=12, ','=13, ':'=14, '!'=15, '='=16, '>='=17, '<='=18, '>'=19, '<'=20, '*'=21, '/'=22, '+'=23, '-'=24, '('=25, ')'=26, '{'=27, '}'=28, '['=29, ']'=30}
